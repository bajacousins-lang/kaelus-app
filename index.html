import os
import time
import threading
import requests
from datetime import datetime, timedelta
from bs4 import BeautifulSoup
from flask import Flask, jsonify
from flask_cors import CORS
import telebot
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton, WebAppInfo
from pymongo import MongoClient

# --- CONFIGURACI√ìN ---
BOT_TOKEN = os.getenv("TELEGRAM_TOKEN")
ADMIN_ID = str(os.getenv("ADMIN_ID"))
MONGO_URI = os.getenv("MONGO_URI")
WEBAPP_URL = "https://bajacousins-lang.github.io/kaelus-app/index.html"
SOURCE_URL = "https://kaelustvsporte.com"

# DB Setup
client = MongoClient(MONGO_URI)
db = client['bcntv_database']
subs_col = db['suscripciones']
users_col = db['usuarios']

app = Flask('')
CORS(app)

# --- SCRAPER AVANZADO ---
def get_kaelus_content(category):
    headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) BCNTV-Premium/1.0"}
    try:
        # Petici√≥n con tiempo de espera corto para no congelar el bot
        res = requests.get(SOURCE_URL, headers=headers, timeout=8)
        soup = BeautifulSoup(res.text, 'html.parser')
        
        # Seleccionamos enlaces con texto relevante
        links = soup.find_all('a', href=True)
        found = []
        
        for l in links:
            title = l.get_text().strip()
            url = l['href']
            # Filtro inteligente: evita enlaces cortos como "Inicio" o "Contacto"
            if len(title) > 12 and url.startswith('http'):
                found.append(f"<b>‚Ä¢</b> <a href='{url}'>{title}</a>")
        
        if not found: return "üì≠ No hay eventos nuevos ahora."
        
        # Unimos m√°ximo 7 resultados para no saturar
        header_text = f"üéØ <b>√öLTIMO EN {category.upper()}</b>\n<i>Fuente: KaelusTV</i>\n\n"
        return header_text + "\n\n".join(found[:7])
    except Exception as e:
        return "‚ö†Ô∏è Error temporal de conexi√≥n con la fuente."

# --- BOT ---
bot = telebot.TeleBot(BOT_TOKEN, parse_mode="HTML")

@bot.callback_query_handler(func=lambda c: c.data.startswith('scr_'))
def handle_scraping_call(call):
    cat = call.data.split('_')[1]
    bot.answer_callback_query(call.id, text="Consultando KaelusTV...")
    content = get_kaelus_content(cat)
    bot.send_message(call.message.chat.id, content, disable_web_page_preview=True)

# L√≥gica de Inicio
@bot.message_handler(commands=['start'])
def send_welcome(message):
    uid = str(message.from_user.id)
    # Saludo basado en hora (Ajuste -5 para GMT-5)
    hour = (datetime.now().hour - 5) % 24
    greet = "¬°Buenos d√≠as!" if 5 <= hour < 12 else "¬°Buenas tardes!" if 12 <= hour < 20 else "¬°Buenas noches!"
    
    markup = InlineKeyboardMarkup(row_width=2)
    markup.add(
        InlineKeyboardButton("‚öΩ DEPORTES", callback_data="scr_deportes"),
        InlineKeyboardButton("üé¨ PEL√çCULAS", callback_data="scr_peliculas")
    )
    markup.add(InlineKeyboardButton("üåê WEB PREMIUM", web_app=WebAppInfo(url=WEBAPP_URL)))
    
    bot.send_message(message.chat.id, f"<b>{greet} {message.from_user.first_name}</b>\nBienvenido a la experiencia BCNTV.", reply_markup=markup)

# API para Keep-Alive y WebApp
@app.route('/')
def status(): return "OK"

def run_flask():
    app.run(host='0.0.0.0', port=int(os.environ.get("PORT", 10000)))

if __name__ == "__main__":
    threading.Thread(target=run_flask, daemon=True).start()
    bot.remove_webhook()
    bot.infinity_polling()
